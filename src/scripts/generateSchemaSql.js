import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { DataTypes } from "sequelize";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

process.env.NODE_ENV ||= "development";

const { sequelize } = await import("../config/database.js");
await import("../models/index.js");

const queryGenerator = sequelize.getQueryInterface().queryGenerator;

const makeIndexIdempotent = (sql) =>
  sql.replace(/^CREATE (UNIQUE )?INDEX /, "CREATE $1INDEX IF NOT EXISTS ");

const outputPath =
  process.argv[2] ?? path.resolve(__dirname, "../../schema.sql");

const modelsTopo = sequelize.modelManager.getModelsTopoSortedByForeignKey();
const modelsInCreateOrder = (modelsTopo ?? sequelize.modelManager.models).slice();
if (modelsTopo) modelsInCreateOrder.reverse();

const seenEnumNames = new Set();
const statements = [];

statements.push(`-- Generated by src/scripts/generateSchemaSql.js`);
statements.push(`-- Paste into your Postgres/Supabase SQL editor`);
statements.push(`CREATE EXTENSION IF NOT EXISTS postgis;`);
statements.push(`CREATE EXTENSION IF NOT EXISTS pgcrypto;`);

for (const model of modelsInCreateOrder) {
  const tableName = model.getTableName();

  const normalizedAttributes = {};
  for (const [attributeName, rawAttribute] of Object.entries(
    model.rawAttributes
  )) {
    normalizedAttributes[attributeName] =
      sequelize.normalizeAttribute(rawAttribute);
  }

  for (const [attributeName, attribute] of Object.entries(normalizedAttributes)) {
    const fieldName = attribute.field || attributeName;
    const type = attribute.type;
    const enumType =
      type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM
        ? type.type
        : type;

    if (!(enumType instanceof DataTypes.ENUM)) continue;

    const enumName = queryGenerator.pgEnumName(tableName, fieldName);
    if (seenEnumNames.has(enumName)) continue;
    seenEnumNames.add(enumName);

    statements.push(queryGenerator.pgEnum(tableName, fieldName, enumType));
  }

  const attributesSql = queryGenerator.attributesToSQL(normalizedAttributes, {
    table: tableName,
    context: "createTable",
  });

  const createTableSql = queryGenerator.createTableQuery(
    tableName,
    attributesSql,
    { uniqueKeys: model.uniqueKeys, comment: model.options.comment }
  );

  statements.push(createTableSql);
}

for (const model of modelsInCreateOrder) {
  const tableName = model.getTableName();
  const indexes = model.options.indexes ?? [];

  for (const index of indexes) {
    const sql = queryGenerator.addIndexQuery(tableName, index.fields, index);
    statements.push(`${makeIndexIdempotent(sql)};`);
  }
}

await fs.writeFile(outputPath, `${statements.join("\n\n")}\n`, "utf8");
console.log(`Schema SQL written to: ${outputPath}`);
