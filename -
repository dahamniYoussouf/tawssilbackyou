    const totalRestaurants = restaurants.length;
    const activeRestaurants = restaurants.filter(r => r.is_active).length;
    const premiumRestaurants = restaurants.filter(r => r.is_premium).length;
    const approvedRestaurants = restaurants.filter(r => r.status === 'approved').length;

    // Get driver statistics
    const drivers = await Driver.findAll({
      attributes: ['id', 'status', 'is_active', 'is_verified']
    });
    const totalDrivers = drivers.length;
    const availableDrivers = drivers.filter(d => d.status === 'available').length;
    const busyDrivers = drivers.filter(d => d.status === 'busy').length;
    const offlineDrivers = drivers.filter(d => d.status === 'offline').length;

    // Get client statistics
    const clients = await Client.findAll({
      attributes: ['id', 'is_active', 'is_verified']
    });
    const totalClients = clients.length;
    const activeClients = clients.filter(c => c.is_active).length;
    const verifiedClients = clients.filter(c => c.is_verified).length;

    // Get notification statistics
    const notifications = await AdminNotification.findAll({
      attributes: ['id', 'is_read', 'is_resolved', 'type', 'created_at']
    });
    const totalNotifications = notifications.length;
    const unreadNotifications = notifications.filter(n => !n.is_read).length;
    const unresolvedNotifications = notifications.filter(n => !n.is_resolved).length;
    const resolvedNotifications = notifications.filter(n => n.is_resolved).length;

    const announcementRecords = await Announcement.findAll({
      attributes: ['id', 'is_active', 'restaurant_id'],
      include: [{
        model: Restaurant,
        as: 'restaurant',
        attributes: ['id', 'name']
      }]
    });
    const totalAnnouncements = announcementRecords.length;
    const activeAnnouncements = announcementRecords.filter(a => a.is_active).length;
    const announcementGroups = new Map();
    announcementRecords.forEach((announcement) => {
      const restaurantRef = announcement.restaurant || null;
      const key = restaurantRef?.id || 'global';
      if (!announcementGroups.has(key)) {
        announcementGroups.set(key, {
          restaurant: restaurantRef ? { id: restaurantRef.id, name: restaurantRef.name } : null,
          total: 0,
          active: 0
        });
      }
      const bucket = announcementGroups.get(key);
      bucket.total += 1;
      if (announcement.is_active) {
        bucket.active += 1;
      }
    });
    const announcementBreakdown = Array.from(announcementGroups.values());

    // Calculate growth (compare with previous month - simplified for now)
    // In a real implementation, you'd compare with previous period
    const orderGrowth = 12.5; // Mock value - should be calculated from historical data
    const revenueGrowth = 18.3; // Mock value - should be calculated from historical data

    const statistics = {
      orders: {
        total: totalOrders,
        pending: pendingOrders,
        completed: completedOrders,
        cancelled: cancelledOrders,
        inProgress: inProgressOrders,
        growth: orderGrowth
      },
      revenue: {
        total: parseFloat(totalRevenue.toFixed(2)),
        average: parseFloat(avgOrderValue.toFixed(2)),
        growth: revenueGrowth
      },
      restaurants: {
        total: totalRestaurants,
        active: activeRestaurants,
        premium: premiumRestaurants,
        approved: approvedRestaurants
      },
      drivers: {
        total: totalDrivers,
        available: availableDrivers,
        busy: busyDrivers,
        offline: offlineDrivers
      },
      clients: {
        total: totalClients,
        active: activeClients,
        verified: verifiedClients
      },
      notifications: {
        total: totalNotifications,
        unread: unreadNotifications,
        unresolved: unresolvedNotifications,
        resolved: resolvedNotifications
      }
    };

    // Cache for 2 minutes (120 seconds)
    await cacheService.set(cacheKey, statistics, 120);

    res.json({
      success: true,
      data: statistics,
      cached: false
    });
  } catch (err) {
    next(err);
  }
};

/**
 * GET /admin/monitoring
 * System and API monitoring snapshot
 */
export const getMonitoringSnapshot = async (req, res, next) => {
  try {
    const cacheKey = 'admin:monitoring:snapshot';
    const cached = await cacheService.get(cacheKey);

    if (cached) {
      return res.json({
        success: true,
        data: cached,
        cached: true
